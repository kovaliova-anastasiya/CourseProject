Для каждой вершины будем хранить значение, равное числу вершин, которые смежны с ней и уже имеют информацию. Идея алгоритма в том, чтобы находить кандидата для вершины, имеющего наименьшее такое значение. После того, как для какой-то вершины мы нашли кандидата, мы помечаем его как того, кого не стоит рассматривать как того, кому можно попытаться отправить информацию. При этом дополнительное хранимое значение мы будет пересчитывать только после того, как для каждой вершины будет найден кандидат и полученное множество кандидатов войдёт в множество вершин с информацией. Если этот пересчёт делать сразу, вершины-кандидаты будут искаться так, будто эта новая вершина на этом шаге будет искать кандидата, но это не так.

Сложность алгоритма -- $\mathcal{O}(nm)$.
