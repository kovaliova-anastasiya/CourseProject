
В целом стандартный алгоритм планировщика в ядре 4.3BSD схож с алгоритмом ''О(1)'', некоторые различия приведены в Таблице~\ref{Tables:BsdLinuxO(1)diff}. Также в этом разделе будут более подробно рассмотрены некоторые моменты, связанные с планированием, которые опускались до этого \cite{vahalia} .\\

\begin{table}[H]
\begin{tabularx}{\textwidth}{|X|X|X|}
\hline
\textbf{Признак для сравнения} & \textbf{4.3BSD} & \textbf{Linux 2.6}\\
\hline
	Количество очередей для хранения процессов & 32 & 140\\
\hline
	Диапазон значений приоритетов & 0-127& 0-139\\
\hline
	Очередь отвечает  за номера приоритетов & 4 подряд идущих с соответствующим смещением & соответствует 		номеру  очереди\\
\hline
	Распределение приоритетов по назначению процесса&0-49 - для ядра, 50-127 - прикладные процессы & Первые 100 - задачи реального времени, последние 40 - пользовательские задачи\\
\hline
	Функция нахождения первого ненулевого бита& Присутствует для 32-битного числа. & Для битового массива\\
\hline
\end{tabularx}
\caption{\textbf{Некоторые различия в реализации алгоритма O(1) в системах 4.3BSD и Linux 2.6}}
\label{Tables:BsdLinuxO(1)diff}
\end{table}
Раньше неоднократно замечалось , что процессы, ограниченные скоростью работы устройств ввода-вывода,после выхода из состояния блокировки должны как можно скорее получить ЦП в свое пользование. Рассмотрим механизм, с помощью которого обеспечивается такое подведение на примере 4.3BSD.\\Каждому событию, ресурсу, системному вызову поставим в соответствие так называемый \textbf{приоритет сна}, величина которого лежит в диапазоне приоритетов ядра (0-49). После того, как процесс выходит из состояния блокировки, система его приоритет приравнивает к приоритету сна ресурса, события, системного вызова, с которым работал процесс. Так как приоритеты ядра выше всех остальных приоритетов, то такие процессы будут приняты к исполнению раньше всех остальных пользовательских процессов. После этого приоритет процесса сбрасывается к первоначальному , и процесс участвует в планировании наравне с остальными до следующей блокировки.\\
На приоритет процесса влияет не только степень использования последнего кванта времени, но и \textbf{значение  любезности}. Назначение этой характеристики - задание степени ''уступчивости'' процессорного времени конкретным процессом. Стандартное значение любезности для процесса - 20 при диапазоне значений от 0 до 39.\\
Так как системы 4.3BSD и Linux являются UNIX-подобными и часто используются в качестве серверных ОС, то их можно позиционировать как \textbf{системы разделения времени} [см. определение], для которых важно условное равенство всех задач. Как я уже отмечал [см. \ref{linux:cfs}], эти системы динамически изменяют приоритеты процессов, чтобы процессы разделяли ЦП примерно поровну. Вводится понятие \textbf{фактора полураспада}, значение которого обозначим переменной $decay$. В 4.3BSD он вычисляется по формуле:
\begin{equation}
decay = \frac{2 * load\_av}{2 * load\_av + 1}  
\end{equation}
Здесь $load\_av$ - среднее количество процессов, готовых к выполнению, за последнюю секунду (пересчет запускается раз в секунду). К разных системах формулы для расчета могут отличаться, вплоть до использования константного значения. Фактор полураспада $decay$ влияет на процессорное время, выделяемое процессу, в зависимости от загруженности системы. Если загрузка велика, то значение $decay$ расположено близко к единице, и он не играет существенной роли. Если же готовых процессов не много, то влияние коэффициента будет ощутимо - снижение приоритетов будет происходить быстро, что решает проблему процессов с изначально низким приоритетом (''голодание''), так как они получат процессорное время после снижения приоритетов более предпочтительных  процессов. \\
\label{unix:priority}
Приоритет процесса $usr\_proc\_pr$ пересчитывается по формуле:
\begin{equation}
usr\_proc\_pr = USER\_DEFAULT\_PR + \frac{cpu\_usage}{4} + 2 * nice\_value
\end{equation}
Здесь $USER\_DEFAULT\_PR$ - стандартное значение приоритета для пользовательских задач, в 4.3BSD равно 50, $cpu\_usage$ -  результат последнего измерения использования процессорного времени, $nice\_value$ - значение любезности для текущего процесса. Можно сделать следующие выводы:
\begin{enumerate}[label=---]
\item Чем больше процесс использовал ЦП в последний раз ($cpu\_usage$), тем выше будет числовое значение приоритета, тем ниже фактический приоритет процесса.
\item Чем выше значение ''любезности'', тем выше числовое значение приоритета, тем ниже фактический приоритет. Значение любезности можно добровольно понижать, заложив такую логику в исходном коде программы или использовав утилиту $renice$ терминала.
\item Нет необходимости обновлять приоритеты обходом списка процессов, эту задачу решает использование формулы.
\end{enumerate}
Таким образом, планировщик в 4.3BSD является достаточно эффективным для средне нагруженных систем, но все же имеет несколько ограничений:
\begin{enumerate}[label=---]
\item При увеличении количества процессов пересчет $decay$ каждую секунду станет не выгоден.
\item Не дает гарантий по времени реакции для приложений реального времени.
\item Реализовано ''мягкое'' вытеснение: если система функционирует в режиме ядра , то процесс будет вытеснен только при переходе обратно в пользовательский режим.
\end{enumerate} 
