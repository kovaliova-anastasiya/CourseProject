Так как содержимое файлов может быть достаточно объемным, сортировка может заняться существенное время. Далее предполагается, что содержимое файлов полностью помещается в оперативную память компьютера, то есть отсутствует необходимость применять алгоритмы внешней сортировки. Чтобы уменьшить предполагаемое время сортировки, воспользуемся псевдо-параллельной обработкой. В задаче явно прослеживаются независимые друг от друга фрагменты: файлы, которые должны быть отсортированы, являются независимыми по отношению друг к другу. Исходя из этого, рассмотрим следующий алгоритм:
\begin{enumerate}[label=---]
\item Процесс, назначение которого - непосредственная сортировка, будем называть $Sorter$ \label{practice:sorter}.
\item Главный процесс назовем $Distributor$ \label{practice:distributor}, его назначение - порождение группы обработчиков $Sorter$ и передача им параметров, необходимых для распределения нагрузки внутри рабочей группы.
\item $Distributor$ принимает от пользователя количество файлов (для простоты), которые нужно отсортировать, а также количество процессов типа $Sorter$ в рабочей группе.
\item $Distributor$ порождает процессы из рабочей группы, в каждый из них передается порядковый номер процесса и все параметры, которые $Distributor$ получил сам. 
\item Каждый из процессов $Sorter$ принимает переданные параметры и на их основе выбирает назначенные ему файлы, читает из каждого данные, сортирует их, записывает результат в новый файл, возвращает код завершения.
\item $Distributor$ ожидает завершения всех порожденных процессов, сообщая пользователю об ошибках, если таковые возникли в дочерних процессах. Убедившись, что все процессы из рабочей группы успешно завершили работу, $Distributor$ прекращает свое выполнение.
\end{enumerate}
Генерация входных данных осуществляется с помощью Python-скрипта, вызов которого имеет формат:
\lstinputlisting[language=Bash]{source_code/input_script_exec.sh}
Пример входных данных:
\lstinputlisting[language=Bash]{source_code/data_sample.txt}
Реализация $Sorter$ одинакова для систем Unix, Linux, Windwos и для сортировки использует C++ STL. Различия в реализации в перечисленных выше ОС появляются в $Distributor$, поскольку разные ОС предоставляют разные API для выполнения системных вызовов.