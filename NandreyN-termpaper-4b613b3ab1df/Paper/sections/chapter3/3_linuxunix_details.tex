Порождение нового процесса в ОС Linux/Unix происходит с помощью системного вызова $fork()$ \cite{lav}. Порожденный процесс является практически полной копией родительского процесса и почти сразу начинает свое выполнение. Затем , с помощью семейства системных вызовов $exec()$ \cite{lav} происходит замещение текущего содержания адресного пространства, и процесс готов к выполнению новой программы.\\
Пусть вызвана операция $fork()$. При успешном создании нового процесса оба из них продолжают выполнение от вызова $fork()$ (Пример из исходного кода приведен в Листинге \ref{lst:lin_fork}. ).
\lstinputlisting[caption=Запуск процессов в Linux/Unix, captionpos=b,label={lst:lin_fork}]{source_code/linux_distributor.txt}

Однако они получат различные коды возврата, которые являются текущим $pid$ процесса. В дочернем процессе успешный вызов $fork()$ вернет $0$, в родительском процессе - $pid$ дочернего. С помощью возврата функции ветвления можно определять дальнейшее поведение родительского и дочернего процессов.\\
Функции из семейства $exec()$ замещают текущий образ новым, загружая в память программу и аргументы, определяемые параметрами системного вызова. В своей реализации я использовал системный вызов $execl()$, поскольку он позволяет передавать несколько параметров командной строки, что мне и требуется.\\
После того, как $Distributor$ распределил нагрузку, он, как и в реализации под Windows, ждет завершения дочерних процессов (т.е. переходит в состояние блокировки). Пример кода приведен в Листинге \ref{lst:lin_wait}.

\lstinputlisting[caption=Ожидание завершения процессов в Linux/Unix, captionpos=b, label={lst:lin_wait}]{source_code/linux_wait.txt}
