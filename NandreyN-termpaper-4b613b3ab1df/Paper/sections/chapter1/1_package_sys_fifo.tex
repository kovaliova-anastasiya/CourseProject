Самым простым является алгоритм "Первым пришел - первым обслужен" \cite{ubuntuman} \cite{tanenbaum}. При использовании такого алгоритма роль планировщика заключается в предоставлении процессорного времени процессам в порядке "живой очереди". Приоритетом процесса в таком алгоритме является время поступления процесса на обработку: чем раньше он поступил, тем выше его приоритет. Процесс имеет право занимать ЦП сколь угодно долго: до завершения или до перехода в состояние блокировки. В последнем случае при пробуждении процесс помещается в конец очереди. 

Недостатки алгоритма:
\begin{enumerate}[label=---]

\item Не учитывает особенностей процессов, кроме их приоритета. Из-за этого легко смоделировать ситуацию, когда процесс, не требовательный к ресурсам, может долго ожидать процессорного времени из-за гораздо более требовательных процессов, поступивших ранее. Также алгоритм не учитывает ограниченность по скорости вычислений и времени работы устройств ввода-вывода. Под этим понимается ресурс, к которому наиболее требователен процесс: ЦП или устройство ввода-вывода.

\item Из-за простоты алгоритма его сложно масштабировать: при увеличении количества процессов в очереди существенно увеличивается оборотное время процесса.
\end{enumerate} 

Достоинства алгоритма:
\begin{enumerate}[label=---]
\item Весьма прост для понимания и реализации. При реализации можно отказаться от приоритетной очереди, заменив ее двусвязным списком. При поступлении нового процесса на обработку он помещается в конец списка, при назначении процесса на выполнение извлекается процесс из начала списка. Работа с началом и концом двусвязного списка осуществляется за гарантированное время $O(1)$, то есть эффективность смены исполняющегося процесса напрямую зависит от эффективности смены контекста процессов и не зависит от количества процессов в очереди.
\end{enumerate}