Непосредственно во время выполнения процесс может находиться в основных трех состояниях \cite{tanenbaum}: 
\begin{enumerate}[label=---]
\item Блокировка.
\item Выполнение.
\item Готовность.
\end{enumerate}
\textbf{Блокировка}. Процесс блокируется из-за того, что его выполнение не может быть продолжено по тем или иным соображениям. Наиболее частые из них - решение планировщика поставить на выполнение другую задачу, зависимость от данных, которые еще не были вычислены, ожидание какого-либо внешнего события. Соответственно, из этого состояния он может быть выведем возникновением события, разрешающего возникшую зависимость.\\
\textbf{Выполнение}. Процесс в текущий момент времени занимает ЦП машины.\\
\textbf{Готовность}. Данные, необходимые для работы, текущего процесса получены и процесс ожидает решения ОС предоставить ему процессорное время.\\
Переходы между состояниями выполнения и готовности тесно связаны с работой планировщика процессов. Его   основной миссией является задача распределения процессорного времени между процессами таким образом, чтобы обеспечить наилучшую производительность, уменьшить энергопотребление и так далее.\\
Понятно, что процесс просто так появиться и начать исполняться в системе не может. Механизм создания процессов должен быть реализован таким образом, чтобы эта операция не приводила к серьезным задержкам в обработке других задач или вообще к приостановке всей системы. На этом этапе семейства ОС реализуют такую функциональность следующим образом:\\
\begin{enumerate}[label=---]
\item Unix+Linux. Основа системы процессов - строгая иерархия (отношения типа предок-родитель). Иерархию процессов удобно представлять в виде корневого дерева. При этом каждая из вершин - родительский процесс для множества процессов, лежащих в поддеревьях этой вершин. Такое устройство позволяет эффективно организовывать обработку системных сигналов: сигнал приходит в корень дерева, по необходимости обрабатывается, и дублируется во все поддеревья. Например, в системе UNIX при инициализации системы создается дерево, корень которого - процесс $init$. Этот процесс разветвляется, порождая по одному процессу на каждый из терминалов. После этого продолжается наращивание дерева от новых оболочек приема команд.\\ 
Порождение нового процесса явно разделено на 2 этапа:
	\begin{enumerate}[label=---]
	\item Создание точной копии родительского процесса, выделение копии уникального идентификатора процесса, добавление записи в таблицу процессов с указанием идентификатора дочернего процесса, содержимое адресного пространства также копируется.
	\item Помещение нового исполняемого кода в дочерний процесс. (Опционально)
	\end{enumerate}
После этого родительский и дочерний процессы продолжают свое выполнение независимо друг от друга.
\item Windows. В системе Windows кроме идентификатора процесс идентифицируется с помощью дескриптора процесса \cite{hart} \cite{rihter}. Идентификатор уникален и неизменен, в то время как дескрипторов для одного и того же процесса может существовать несколько. Это позволяет регулировать разрешения доступа к процессу, например, наследование дескриптора. Регулирование параметров доступа подразумевает, что с процессом могут синхронизировать свое выполнение другие процессы
\end{enumerate}

После того, как процесс выполнит свою задачу, необходимость в выделении процессорного времени ему отпадает. Однако, запись в таблице дескрипторов для завершившегося процесса может быть не удалена сразу. Это объясняется особенностями организации системы процессов ОС.
