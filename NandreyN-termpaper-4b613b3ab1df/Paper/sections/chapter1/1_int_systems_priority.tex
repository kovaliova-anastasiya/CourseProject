В алгоритмах работы планировщика, рассмотренных до этого, неоднократно затрагивалось понятие приоритета процесса. Построение гибкая системы приоритетов позволяет улучшить работу планировщика \cite{tanenbaum} \cite{vahalia} .\\

Пусть планировщик выбирает процесс с наибольшим приоритетом. На каждом прерывании системного таймера будем понижать приоритет  исполняющегося процесса на некоторую фиксированную величину. Когда приоритет текущего процесса станет меньше наибольшего приоритета процессов из очереди, сменим текущий процесс. Понятно, что в конце концов приоритеты процессов станут не положительными. После того,как это произошло для отдельного процесса, он больше не будет участвовать в борьбе за процессорное время.
 
Чтобы "перезапустить" планирование, присвоим всем процессам их изначальные приоритеты и продолжим выполнение с процесса с наивысшим приоритетом. Минусы такого подхода в объеме времени, затраченном на планирование и высоком оборотном времени для процессов с изначально низким приоритетом.Более того, для процессов, ограниченных скоростью работы устройств ввода-вывода, процессор нужно предоставлять немедленно после их выхода из состояния блокировки, иначе они будут также иметь высокое время оборота.\\

Введем для каждого процесса квант времени, в течение которого процесс может занимать ЦП, и разрешим системе задавать значение процесса, а не просто понижать его. Пусть процесс израсходовал $q$-ю часть своего кванта до перехода в режим блокировки, $q \in ]0,1]$. Если задать его приоритет $p$ по формуле $p = \frac{1}{q}$, то процессы, перешедшие в режим блокировки вскоре после начала работы на ЦП, в том числе процессы, ограниченные скоростью работы устройств ввода-вывода, смогут получать процессорное время вскоре после выхода из состояния блокировки (их приоритеты будут достаточно высоки) [см. \ref{unix:priority}]. После того, как все процессы исчерпают свои кванты, обновим их и продолжим выполнение с самого приоритетного процесса.\\

Сгруппируем процессы. За каждой группой закрепим подотрезок упорядоченного списка значений приоритетов в ОС (так, чтобы пересечение подотрезков было пустым множеством и в то же время разбиение полностью покрывало исходное множество приоритетов) и назначим процессы в соответствующие им группы. Теперь приоритетное планирование (в какой либо из форм) будет применяться к группам, а внутри группы можно использовать другой способ планирования. Остается отметить, что при группировке процессов необходимо менять приоритеты групп так, чтобы группам с низким приоритетом также доставалось процессорное время.
   