\label{int:fair}
Важную идею в систему планирования вносит алгоритм справедливого планирования \cite{tanenbaum} . Пусть в системе есть $N$ пользователей, каждый из которых запускает процессы, не обязательно в равных объемах. Алгоритмы, рассмотренные до этого, не распределяли процессорное время между пользовательскими группами процессов.\\
Предположим, что пользователь с номером $i$ запустил $K_i$ процессов, а пользователь $j$ - $K_j$ процессов, причем $K_i << K_j$. При использовании циклической схемы,как нетрудно заметить, пользователь $j$ получит гораздо больше процессорного времени, нежели пользователь $i$. Из соображений ''справедливости'', объем задач одного пользователя не должен влиять на выделение процессорного времени другому пользователю. Будем полагать, что пользователь с номером $i$ должен получить $T_i$ долю процессорного времени, $\sum T_i = 1, T_i \geq 0, i = 1..n$ и ему принадлежит группа процессов $P_i$, суммарное время владения ЦП которой в момент времени $T$ равно $S_i(T)$.

Тогда доля времени , в течение которого выполнялись процессы из группы $P_i$ : $\tau_i = \frac{S_i(T)}{T}$. Возможны 2 ситуации:
\begin{enumerate}[label=---]
\item $\tau_i < T_i$. Группе процессов было выделено недостаточно времени, тогда планировщик  будет выделять процессорное время этой группе.
\item $\tau_i \geq T_i$. Процессам группы $P_i$ было выделено больше времени, чем требуется. Эти процессы не будут выполняться, пока $\tau_i$ не станет меньше порога.
\end{enumerate}  

Достоинства:
\begin{enumerate}[label=---]
\item Алгоритм позволяет регулировать доступ к ЦП в многопользовательских системах.
\item Планирование является справедливым.
\end{enumerate}

Недостатки:
\begin{enumerate}[label=---]
\item Усложнение алгоритма и увеличение времени работы планировщика , поскольку сначала необходимо выбрать группу, затем процесс внутри группы.
\end{enumerate}

Упростим идею. Вместо групп пользовательских процессов будем рассматривать $N$ независимых процессов, каждый из которых претендует на $T_i = \frac{1}{N}$ долю процессорного времени. Далее используем схему, изложенную выше, относительно процессов, а не пользовательских групп. Реализовать эту схему гораздо проще за счет использования таблицы процессов. В записи таблицы будем хранить информацию о времени создания процесса, а также суммарное время, в течение которого он выполнялся на ЦП. На основании этого нетрудно вычислить долю использованного процессорного времени. Суммарное время выполнения процесса будем редактировать при смене контекста на основании данных системного таймера и отображать результат на соответствующую этому процессу запись в таблице процессов. 